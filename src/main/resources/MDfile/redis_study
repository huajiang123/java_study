##redis
redis是一个基于内存且支持持久化的key-value的NoSql数据库。  
支持的存储的value类型：  
1. String  
2. list  
3. set  
4. zset  
redis会周期性的使用RDB快照方式，把更新的数据写入磁盘或者使用类似Mysql的AOF日志方式把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。  
redis支持将数据同步到多台从数据库上，从而提高读取性能。  
redis可用于：  
1. 缓存  
2. 数据库  
3. 消息中间件  
##需要注意的问题
1. 缓存和数据库双写一致性问题  
对于要求强一致性的，尽量不要使用缓存，只能采取合适的策略来降低缓存和数据库一致性问题。  
三种更新策略：  
    * 先更新数据库，再更新缓存  
    * 先删除缓存，再更新数据库  
    * 先更新数据库，再删除缓存  
###先更新数据库，再更新缓存
这套方案普遍反对  
原因一：（从线程安全的角度）  
同时有请求A和请求B来进行更新操作，那么可能会出现：  
（1）A更新数据库  
（2）B更新数据库
（3）B更新缓存  
（4）A更新缓存
正常来说应该A先更新缓存，可能由于网络问题导致B先更新。从而导致脏数据问题。  
原因二：（从业务角度）  
如果一个业务是写数据库多的话，会导致频繁的更新缓存，因此会导致性能降低。  
###先删除缓存，再更新数据库
该方案会导致不一致的原因是：同时有一个请求A进行更新，一个请求B进行查询操作。则有可能出现以下情形：  
（1）请求A进行更新操作，先删除缓存。  
（2）请求B进行查询，发现缓存中没有，查库。  
（3）请求B查出数据，然后进行更新缓存。  
（4）请求A更新数据库。    
上述情况如果不设置过期事件策略，那么该数据永远是脏数据。  
解决办法：采用延时双删策略。过程如下：  
（1）先淘汰缓存
（2）再写数据库
（3）休眠一秒（具体的时间，由具体的业务决定）
（4）再次淘汰缓存
###先更新库，再删除缓存
当出现以下情形时，会出现一致性问题：  
（1）缓存刚好失效  
（2）请求A查库，得到旧值    
（3）请求B将新值写入数据库  
（4）请求B删除缓存  
（5）请求A将查到的数据放入缓存  
只有当步骤（3）快于步骤（2）时，才会出现这种情况，事实上写库时间是会比查库时间长的。所以要出现这种情况的几率很小。  
####解决缓存删除失败的思路
第二种和第三种方案都会存在这种问题，解决思路有二：  
思路一：  
使用一个消息队列，如果删除失败，则将key放入消息队列中，自己消费消息，获取要删除的key，继续重试删除。  
思路二：  
启动一个订阅程序去订阅数据库binlog，获取需要操作的数据。  

2. 缓存雪崩问题  
缓存在同一时间内大量的key过期，就会有大量的落入数据库中，造成数据库异常。  
解决方案：
    * 将系统中的key的缓存失效时间均匀的分开，防止同一时间有大量的key失效。  
      
如果在分布式环境下需要使用分布式锁，在单机下使用synchronized或者使用lock。  
3. 缓存击穿问题  
缓存击穿是指用户恶意模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在数据库中，导致数据库异常。  
解决方案：  
使用布隆过滤器，将所有可能存在的数据哈西到一个足够大的bitmap中，一个一定不会存在的数据会被bitmap拦截掉，从而避免对底层存储系统的压力。
4. 缓存的并发竞争问题  
多个redis的client同时setkey引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，先到的先执行，其余的阻塞。另外的解决方案是把redis.set操作放在队列中使其串行化 ，必须一个一个执行。  
5. 缓存无底洞问题  
为了满足业务大量加节点，但是性能没有提升反而下降。  
