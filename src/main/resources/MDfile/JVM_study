##JVM模型
<img src="pics/jvm.png" width="50%"/>  
  
##类加载器
按照权限定名将class文件加载到JVM内存，转为Class对象。  
1. BootStrap ClassLoader: rt.jar  
2. Extention ClassLoader: ext目录下的jar包  
3. App ClassLoader： 指定的classpath下的jar包  
4. Custom ClassLoader： 自定义的类加载器  
步骤：  
1. 类加载器接收类加载的请求。  
2. 将这个请求委托给父类去完成，直到委托给根加载器。  
3. 根加载器检查是否能够加载当前这个类，如果可以加载的话就加载并结束，如果不能则抛出异常，让子类加载。  
4. 重复第三步直到加载成功，或者加载失败。  
双亲委派机制：  
当前classloader首先从自己已经加载的类（每个类加载器都有自己的缓存，当一个类加载以后会放入缓存）中查询是否此类已加载，如果已经加载则直接返回。  
当前的classloader的缓存中没有找到被加载的类的时候，委托父类去加载，依次递归。如果父类加载器可以完成加载任务，就成功返回。  
当所有父类加载器都没有加载的时候，再由当前的类加载器加载。并放入缓存中。  
##Native
凡是用了native关键字的，说明java的作用达不到了，会去调用其他语言的库。  
会进入本地方法栈。Native Method Stack，登记所有native方法。    
调用本地方法接口，也就是JNI。  
JNI的作用：扩展java使用，结合不同的编程语言为java所用，例如c，c++。  
##程序计数器
程序执行的下条指令的位置。  
##方法区
静态变量static，常量final，Class类信息（构造方法，接口定义），运行时的常量池存在方法区中。但是实例变量存在内存的堆中，和方法区无关。  
##栈 线程级
栈内存，主管程序运行，生命周期与线程同步，线程结束，栈内存就释放，对于栈来说，不存在垃圾回收问题。  
栈：8大基本类型+对象引用（即对象在堆中的地址）+实例方法。  
程序正在执行的方法一定在栈顶。  
画出一个对象在内存中实例化的过程。  
##对象的实例化过程
1. 类加载检查：当虚拟机遇到一个new指令时，先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过，解析和初始化过。如果没有则进行初始化过程。  
2. 内存分配：就是把这个对象放到堆中具体说来应该是新生区。具体的分配算法是由java堆是否规整决定。java对是否规整又是由垃圾收集器是否带有压缩整理功能决定。  
    * 指针碰撞：适用于堆内存连续的情况下，就像是连续分配。  
    * 空闲列表：适用于对内存离散的情况下，类似离散分配。  
3. 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象的实例字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。  
4. 设置对象头：虚拟机要对对象进行必要的设置，例如：对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈西码，对象的GC分代年龄等。  
5. 执行init方法：进行初始化，类似于执行构造函数，为成员变量赋初值。这样一个真正可用的对象才算产生出来。  
###对象的内存布局
在hotspot虚拟机中，对象在内存中可以分为三个部分：  
1. 对象头  
    * 用于存储对象自身的运行时数据（对象的哈西码，对象的GC分代年龄等）
    * 类型指针：即对象指向他的类元数据的指针，虚拟机通过这个指针来确定是哪个类的实例。  
2. 实例数据：就是程序中所定义的各种类型的字段内容。  
3. 对齐填充：不是必然存在的，仅仅起一个占位的作用。 hotspot虚拟机要求对象的大小必须要是8字节的整数倍。而对象头部分正好是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。  
###对象的访问定位
java程序通过java栈上的reference数据来操作堆上的具体对象。对象的访问模式由虚拟机实现而定，目前的主流访问方式有1使用句柄和2直接指针两种。  
1. 使用句柄方式：即reference指向的句柄池中（将堆划分成两个部分，一个是句柄池，一个是实例池）是对象的句柄地址（句柄中包含了对象实例数据和类型数据各自的具体地址信息）  
2. 直接指针：即reference中存储的直接就是对象在堆中的地址。  
使用句柄的最大的优势在于：当对象发生移动时，只需改变句柄池中的实例对象地址。  
使用直接指针的最大的优势在于：可以减少一次查询，速度快。  
##堆
###三种JVM
hotspot  
jrocket
j9vm  
一个jvm只有一个堆内存，堆内存的大小是可以调节的。  
类加载器在读取了类文件后一般会把，类，方法，常量，变量，保存我们所有引用类型的真实对象。  
堆内存中还要细分为三个区域：  
1. 新生区  轻回收  
    * 伊甸园区 :对象都是在这里new出来的
    * 幸存区0区  
    * 幸存区1区  
2. 养老区  重回收  
新生代:老年代 = 1：2  
edem：from：to = 8：1：1  
设置Survivor的的意义在于： 减少从新生区送入老年区的对象数量，从而控制fullGC的发生频率。  
而设置两个两个Survivor的意义在于：避免内存碎片的发生。  
3. 永久区（jdk8以后叫元空间。逻辑上存在，物理上不存在）：这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据。即存储java运行时的一些环境。这个区域不会进行垃圾回收。  
<img src="/usr/myjavaprojects/java_study/src/main/resources/pics/heap.png" width="50%"/>  
##GC
垃圾回收在堆中，大部分发生在新生区。  
怎么判断一个对象是否应该被回收：  
1. 引用计数法： 会出现循环引用的情况，不能采取;  
2. 可达性分析： 定义了一系列称为GCRoots的对象作为起始点，从这个起始点开始向下搜索，每一条可达的路径称为引用链，当一个对象没有任意一条引用链可到达GCRoot时，那么就对它进行第一次标记
   如果没有自救，会进行第二次标记，此时对象就可以回收。  
可以作为GCRoots的对象有以下几种： 
    1. 虚拟机栈中（栈帧中的本地变量表）引用的对象
    2. 方法区中类静态属性引用的对象  
    3. 方法区中常量引用的对象  
    4. 本地方法栈中JNI引用的对象  
对象在被第一次标记后是有机会进行自救的，需要覆写Object的finalize方法。  
如果程序一边执行，一边进行可达性分析的标记操作，那么就有可能刚标记完一个对象，这个对象又被再次赋值给其他引用。这样就有可能回收掉正在使用的对象。  
解决这个问题的方式就是使用StoptheWold，stw会在所有线程到达一个安全点时，暂停掉所有应用线程的执行，然后开始专心的进行垃圾回收。这样就保证了数据一致性，不会导致错误回收。  
三种GC算法：  
1. 引用计数法  
使用计数器对每个对象的引用进行计数，将引用次数最小的淘汰。  
2. 复制算法：主要用在新生区  
每次GC后就将伊甸园区中的活着的对象移到幸存区，伊甸园区就会为空。  
默认情况下，当一个对象经历了15次GC后幸存下来就会进入老年区。  
优点： 没有内存碎片。  
缺点： 浪费内存空间，浪费一半的内存空间。  
一般应用于对象存活度较低的情况下。  
3. 标记清除算法：老年区  
扫描堆中的对象，将活着的对象进行标记。  
对没有标记的对象进行清除。  
优点：不需要额外的内存空间。  
缺点：两次扫描，严重浪费空间，会产生内存碎片。  
4. 标记压缩：老年区  
压缩防止内存碎片产生。  
再次扫描，将碎片整理成为连续的内存区域。  
可以采取标记清除到一定次数后再进行压缩。  
缺点：多一个移动成本。  
5. 总结  
内存效率： 复制算法>标记清除算法>标记压缩算法（时间复杂度）  
内存整齐度： 复制算法 = 标记压缩算法 > 标记清除算法  
内存利用率： 标记压缩 = 标记清除 > 复制算法  
GC：分代收集算法  
###常用的垃圾收集器
1. Serial收集器: 单线程的，而且它会使用"stop the world"。但是简单，效率高。对于运行在client模式下的虚拟机是个不错的选择。   
2. ParNew收集器: 它是Serial收集器的多线程版本，运行在Server模式下的虚拟机的首选，能与CMS收集器很好的配合。  
3. Parallel Scavenge收集器  
4. Serial Old收集器  
5. Parallel Old收集器  
6. CMS收集器  
7. G1收集器  
##java内存模型 JMM
JMM其实是一种规范：它规定了所有的变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存存储有它用到的变量的副本。  
线程工作的时候只能修改自己的工作内存中的数据，不能直接修改主内存的数据。不同线程无法直接访问对方工作内存中的数据，线程间的变量传递均需要自己的工作内存和主存间进行数据同步。  
###指令重排
在实际运行时，代码指令可能不是严格按照代码语句执行的。大多数微处理器会采用指令乱序执行。其实就是说，因为在条件允许的情况下，直接运行当前有能力继续执行的后续指令，避开获取下一条指令的等待。通过乱序技术可以大大提高执行效率。  
###内存屏障
内存屏障是一个cpu指令。作用：确保一些特定操作的执行顺序（即防止指令重排，屏障的前一个指令和后一个指令），影响一些数据的可见性。  
分类：  
1. LoadLoad屏障：
    * 序列 Load1,LoadLoad,Load2  
    * 确保Load1要比Load2先访问数据。  
2. StoreStore屏障：  
    * 序列 Store1,StoreStore,Store2  
    * 确保Store1的数据在Store2先刷新进主存  
3. LoadStore屏障：
    * 序列 Load1,LoadStore,Store2  
    * 确保Load1的数据在Store2及其后续指令刷新前读取数据。  
4. StoreLoad屏障：
    * 序列 Store1,StoreLoad,Load2  
    * 确保Store1的数据在被Load2及其后续指令访问前要先刷新内存。  
java中应用：  
Synchronized: 实际上是插入了StoreStore屏障。  
volatile： 在对变量的写操作时，实际上是插入了StoreLoad屏障。也就是说volatile是通过内存屏障来实现并发时的一致性，和可见性的。
    * volatile 不具有原子性是因为对volatile修饰的变量可能不具有原子性。例如：volatile++操作，这是一组操作，可以分解为三个操作，1）读取变量，2）加法运算，3）写内存。而这三个操作之间是可以打断的。从而也就不能保证原子性。    
剩下的操作，则需要通过unsafe类来执行。  
###happen-before原则
###JVM几种主要的参数
1. -Xmx3550m：最大堆大小为3550m  
2. -Xms3550m：初始堆大小为3550m  
3. -Xmn2g:设置年轻代的大小为2g  
4. -Xss128k：每个线程对战大小为128k  
5. -XX：MaxPermSize：设置持久代的大小
6. -XX:NewRatio=4：设置年轻代与老年代的比值  
垃圾收集器相关的  
1. -XX：+UseParallelGC  
2. -XX：ParallelGCThread=20：配置并行收集器的线程数  
3. -XX：+UseConcMarkSweepGC：设置老年代并发收集。  
4. -XX：CMSFullGCsBeforeCompaction：设置运行多少次GC以后对内存空间进行压缩，整理。  
5. -XX：UseCMSCompactionAtFullCollection：打开对老年代的压缩。  
辅助信息相关的  
1. -XX：+PrintGC  
2. -XX：+PrintGCDetails  
###强引用，软引用，弱引用，虚引用
1. 强引用：平时直接new的对象就是强引用。只有当引用显示的设置为o或者null时，才会被GC。  
2. 软引用：内存充足时，不会GC，内存不足时，才GC。 SoftReference softreference = new SoftReference(obj);  
3. 弱引用：不管当前内存是否充足，都会进行GC。 WeakReference weakreference = new WeakReference(obj);  
4. 虚引用：虚引用并不会决定对象的生命周期。跟没有引用一样。
##String类和常量池
String对象有两种创建方式：  
1. 从常量池中拿。  
2. 直接在堆内存空间中创建一个新的对象。  
String常量池，使用方法主要有两种：  
1. 直接使用双引号声明出来的String对象会直接放入常量池中。  
2. 如果不是使用双引号声明的String对象，可以使用string.intern()方法。intern()方法是一个native方法，  
它的作用是：如果运行时常量池中已经包含了一个等于此String对象内容的字符串，则返回常量池中该字符串的引用，如果没有则在jdk1.7以后的版本中，是在常量池中记录该字符串的引用，并返回该引用。  
##String s1 = new String("abc");
此语句可能会创建一个或者两个对象：  
1. 当池中有字符串常量（abc）时，只会在堆空间中创建一个对象。  
2. 当池中不存在时，就会在池和堆中都创建对象。  
